"use strict";
/**
 *
 * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPortableTextMarkModel = void 0;
const slate_1 = require("slate");
const lodash_1 = require("lodash");
const debug_1 = require("../../utils/debug");
const selection_1 = require("../../utils/selection");
const debug = debug_1.debugWithName('plugin:withPortableTextMarkModel');
function createWithPortableTextMarkModel(portableTextFeatures, change$) {
    return function withPortableTextMarkModel(editor) {
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations
        const { normalizeNode } = editor;
        editor.normalizeNode = nodeEntry => {
            normalizeNode(nodeEntry);
            if (editor.operations.some(op => op.type === 'merge_node')) {
                mergeSpans(editor);
            }
            // Check consistency of markDefs
            if (editor.operations.some(op => ['split_node', 'remove_node', 'remove_text', 'merge_node', 'set_selection'].includes(op.type))) {
                normalizeMarkDefsAfterRemoveNode(editor);
            }
            // This should not be needed? Commented out for now.
            // // Ensure that every span node has .marks
            // const [node, path] = nodeEntry
            // if (node._type === portableTextFeatures.types.span.name) {
            //   if (!node.marks) {
            //     debug('Adding .marks to span node')
            //     Transforms.setNodes(editor, {marks: []}, {at: path})
            //   }
            // }
        };
        // Override built in addMark function
        editor.addMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    // Use new selection
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    const shouldRemoveMark = lodash_1.flatten(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    splitTextNodes.forEach(([node, path]) => {
                        const marks = [
                            ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                            mark
                        ];
                        slate_1.Transforms.setNodes(editor, { marks }, { at: path });
                    });
                    mergeSpans(editor);
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: [...existingMarks, mark] });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    splitTextNodes.forEach(([node, path]) => {
                        slate_1.Transforms.setNodes(editor, {
                            marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark)
                        }, { at: path });
                    });
                    mergeSpans(editor);
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: existingMarks.filter(eMark => eMark !== mark) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = (mark) => {
            if (!editor.selection) {
                return false;
            }
            let existingMarks;
            if (slate_1.Range.isExpanded(editor.selection)) {
                const [match] = slate_1.Editor.nodes(editor, { match: slate_1.Text.isText });
                if (match) {
                    const [node] = match;
                    existingMarks = node.marks;
                }
                else {
                    existingMarks = [];
                }
            }
            else {
                const { anchor } = editor.selection;
                const { path } = anchor;
                let [node] = Array.from(slate_1.Editor.nodes(editor, { at: path }))[0] || [undefined];
                if (anchor.offset === 0) {
                    const prev = slate_1.Editor.previous(editor, { at: path, match: slate_1.Text.isText });
                    const block = slate_1.Editor.above(editor, {
                        match: n => slate_1.Editor.isBlock(editor, n)
                    });
                    if (prev && block) {
                        const [prevNode, prevPath] = prev;
                        const [, blockPath] = block;
                        if (slate_1.Path.isAncestor(blockPath, prevPath)) {
                            node = prevNode;
                        }
                    }
                }
                existingMarks = node.marks;
            }
            existingMarks =
                Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
            return existingMarks ? existingMarks.includes(mark) : false;
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = (mark) => {
            const isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug(`Remove mark '${mark}'`);
                slate_1.Editor.removeMark(editor, mark);
            }
            else {
                debug(`Add mark '${mark}'`);
                slate_1.Editor.addMark(editor, mark, true);
            }
            const newSelection = selection_1.toPortableTextRange(editor);
            if (newSelection !== undefined) {
                // Emit a new selection here (though it might be the same).
                // This is for toolbars etc that listens to selection changes to update themselves.
                change$.next({ type: 'selection', selection: newSelection });
            }
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     *
     * @param {Editor} editor
     */
    function mergeSpans(editor) {
        const { selection } = editor;
        if (selection) {
            for (const [node, path] of Array.from(slate_1.Editor.nodes(editor, {
                at: slate_1.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]]),
                match: slate_1.Text.isText
            })).reverse()) {
                const [parent] = slate_1.Editor.node(editor, slate_1.Path.parent(path));
                const nextPath = [path[0], path[1] + 1];
                if (slate_1.Editor.isBlock(editor, parent)) {
                    const nextTextNode = parent.children[nextPath[1]];
                    if (nextTextNode && nextTextNode.text && lodash_1.isEqual(nextTextNode.marks, node.marks)) {
                        slate_1.Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                    }
                }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     * @param {Editor} editor
     */
    function normalizeMarkDefsAfterRemoveNode(editor) {
        const { selection } = editor;
        if (selection) {
            const [blockElement, path] = slate_1.Editor.node(editor, selection.focus, { depth: 1 });
            if (blockElement && blockElement._type === portableTextFeatures.types.block.name) {
                if (Array.isArray(blockElement.markDefs) && slate_1.Element.isElement(blockElement)) {
                    const newMarkDefs = blockElement.markDefs.filter(def => {
                        return blockElement.children.find(child => {
                            return Array.isArray(child.marks) && child.marks.includes(def._key);
                        });
                    });
                    const isEmptySingleChild = blockElement.markDefs.length > 0 &&
                        blockElement.children.length === 1 &&
                        blockElement.children[0].text === '';
                    if (!lodash_1.isEqual(newMarkDefs, blockElement.markDefs) || isEmptySingleChild) {
                        debug('Removing markDef not in use');
                        slate_1.Transforms.setNodes(editor, {
                            markDefs: isEmptySingleChild ? [] : newMarkDefs
                        }, { at: path });
                    }
                }
            }
        }
    }
}
exports.createWithPortableTextMarkModel = createWithPortableTextMarkModel;
//# sourceMappingURL=createWithPortableTextMarkModel.js.map